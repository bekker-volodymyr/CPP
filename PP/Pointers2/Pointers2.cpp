#include <iostream>
#include <Windows.h> // Для функцій роботи з консоллю Windows (SetConsoleOutputCP)
#include <ctime>     // Для функції time() (використовується для ініціалізації генератора випадкових чисел)
#include <cstdlib>   // Для функцій rand() і srand() (генерація випадкових чисел)

using namespace std;

// Прототип шаблонної функції для обміну значень
template <typename T> void SwapValues(T& left, T& right);

// Прототип функції, яка повертає посилання на максимальний елемент масиву
int& rmax(int arr[], int size);

// Прототип функції для додавання елемента до динамічного масиву
void addToArr(int*& arr, int& size, int elem);

// Прототип функції для виведення елементів масиву
void printArr(int* arr, const int& size);

int main()
{
    // Встановлення кодування консолі для коректного відображення українських символів.
    SetConsoleOutputCP(1251);
  
    // Робота з динамічним масивом: додавання елемента
    int count = 5;
    // Створення динамічного масиву на 5 цілих чисел та ініціалізація його значень.
    int* arrDyn = new int[count] {10, 1, 6, -1, 0};

    cout << "Початковий динамічний масив:" << endl;
    printArr(arrDyn, count); // Виведення початкового масиву

    // Додаємо елемент 100 до масиву. Зверніть увагу, що функція addToArr змінює 'arrDyn' та 'count'.
    addToArr(arrDyn, count, 100);
    cout << "Масив після додавання елемента:" << endl;
    printArr(arrDyn, count); 
    
    delete[] arrDyn;
    arrDyn = nullptr; // Гарна практика - обнуляти покажчик після звільнення пам'яті

    cout << "\n--- Покажчики на константні дані та константні покажчики ---\n";

    const int constVal = 10; // Константна змінна

    // Покажчик на константу (дані, на які він вказує, не можна змінити через цей покажчик)
    const int* ptrC = &constVal;

    int a = 10, b = 12;

    // Константний покажчик (сам покажчик не можна перепризначити на іншу адресу)
    int* const ptr = &a;
    // Значення, на яке він вказує, можна змінити.
    *ptr = 23;
    cout << "Значення 'a' після зміни через константний покажчик: " << a << endl; // Вивід: 23

    // Покажчик на константу
    const int* ptrToConst;
    ptrToConst = &a; // Можна перепризначити покажчик на іншу змінну
    ptrToConst = &b;
    // *ptrToConst = 1; // ПОМИЛКА: не можна змінити значення через ptrToConst

    // Константний покажчик на константу (не можна змінити ні значення, ні сам покажчик)
    int number = 0;
    const int* const cPtrToC = &number;
    cout << "Адреса cPtrToC: " << cPtrToC << " --- Значення, на яке вказує cPtrToC: " << *cPtrToC << endl;
    // cPtrToC = &a; // ПОМИЛКА: не можна перепризначити константний покажчик
    // *cPtrToC = 10; // ПОМИЛКА: не можна змінити значення через покажчик на константу

    cout << "\n--- Посилання (References) ---\n";

    // Посилання
    int value = 1234;   
    int* valPtr = &value; // Покажчику присвоєна адреса змінної value
    int& valRef = value;  // Посилання асоційоване з value (valRef є псевдонімом для value)
    int* p = &valRef;     // Покажчику 'p' присвоєно адресу 'valRef', що є адресою 'value'. Тобто 'p' тепер вказує на 'value'.
	
    cout << "value = " << value << "\n";     // Вивід: 1234
    cout << "*valPtr = " << *valPtr << "\n"; // Вивід: 1234
    cout << "valRef = " << valRef << "\n";   // Вивід: 1234
    cout << "*p = " << *p << "\n";           // Вивід: 1234

    double one = 2.4, two = 3.5;

    double& ref = one; // 'ref' стає псевдонімом для 'one'
    cout << "Значення 'one': " << one << endl;  // Вивід: 2.4
    cout << "Значення 'two': " << two << endl;  // Вивід: 3.5
    cout << "Значення 'ref': " << ref << endl;  // Вивід: 2.4

    // Якщо ми присвоюємо значення посиланню, ми змінюємо значення змінної, на яку воно посилається.
    ref = two; // !!! Це НЕ перепризначення посилання. Це присвоєння ЗНАЧЕННЯ 'two' змінній 'one'
               // через посилання 'ref'. 'ref' досі посилається на 'one'.
    cout << "Після 'ref = two;'\n";
    cout << "Значення 'one': " << one << endl;  // Вивід: 3.5
    cout << "Значення 'two': " << two << endl;  // Вивід: 3.5
    cout << "Значення 'ref': " << ref << endl;  // Вивід: 3.5

    cout << "\n--- Шаблонна функція SwapValues ---\n";

    int left = 10, right = 12;
    cout << "До обміну: left = " << left << " --- right = " << right << endl;
    SwapValues(left, right);
    cout << "Після обміну: left = " << left << " --- right = " << right << endl;

    int* ptr2;
    int*& ptrRef = ptr2; // 'ptrRef' є посиланням на покажчик 'ptr2'.

    cout << "\n--- Функція, що повертає посилання (rmax) ---\n";

    const int size = 5;
    int arr[size] = { 10, 4, 15, -9, 0 };

    // 'maxElem' стає посиланням на елемент масиву 'arr', який є максимальним.
    int& maxElem = rmax(arr, size);

    cout << "Максимальний елемент (через посилання): " << maxElem << endl; // Вивід: 15
    maxElem = 0; // Змінюємо значення елемента масиву, на який вказує 'maxElem', на 0
    cout << "Значення елемента arr[2] після зміни через посилання: " << arr[2] << endl; // Вивід: 0

    cout << "\n--- Динамічне виділення пам'яті для одиночних змінних ---\n";

    // Виділення пам'яті в купі (heap) для одиночних змінних за допомогою оператора 'new'.
    // 'new' повертає адресу виділеної пам'яті.
    float* fptr = new float(3.5); // Виділяємо пам'ять для float і ініціалізуємо 3.5
    int* iptr = new int(6);       // Виділяємо пам'ять для int і ініціалізуємо 6
    char* cptr = new char('I');   // Виділяємо пам'ять для char і ініціалізуємо 'I'

    cout << "Значення fptr: " << *fptr << endl;
    cout << "Значення iptr: " << *iptr << endl;
    cout << "Значення cptr: " << *cptr << endl;

    // Звільнення пам'яті, виділеної оператором 'new'.
    // Кожен виклик 'new' повинен мати відповідний 'delete'.
    delete fptr; // Звільняємо пам'ять, на яку вказував fptr
    delete iptr; // Звільняємо пам'ять, на яку вказував iptr
    delete cptr; // Звільняємо пам'ять, на яку вказував cptr
    // Примітка: синтаксис 'delete fptr, iptr, cptr;' не є стандартним способом звільнення кількох покажчиків.
    // Кожен 'delete' має бути окремим оператором.

    cout << "\n--- Динамічне виділення пам'яті для масиву ---\n";

    srand(time(NULL)); // Ініціалізація генератора випадкових чисел

    int s;
    cout << "Введіть розмір масиву (для double): ";
    cin >> s;

    // Динамічне виділення пам'яті під масив типу double розміром 's'.
    double* dArr = new double[s];

    cout << "Елементи динамічного double-масиву:" << endl;
    for (int i = 0; i < s; i++) {
        dArr[i] = rand() % 100; // Заповнюємо випадковими числами (від 0 до 99)
        cout << dArr[i] << "\t";
    }
    cout << endl;

    // Звільнення пам'яті, виділеної для масиву, за допомогою 'delete[]'.
    delete[] dArr;
    dArr = nullptr; // Обнулення покажчика після звільнення

    return 0; // Успішне завершення програми
}

// Функція для додавання елемента до динамічного масиву
// Приймає покажчик на масив та його розмір за посиланням, що дозволяє їх змінювати.
void addToArr(int*& arr, int& size, int elem) {
    // Створюємо новий, більший масив (+1 елемент)
    int* tempPtr = new int[++size]; // Збільшуємо 'size' на 1, а потім використовуємо його для нового масиву
    
    // Копіюємо елементи зі старого масиву в новий
    for (int i = 0; i < size - 1; i++) {
        tempPtr[i] = arr[i];
    }
    // Додаємо новий елемент в кінець нового масиву
    tempPtr[size - 1] = elem;
    
    // Звільняємо пам'ять, яку займав старий масив
    delete[] arr;
    // Переназначаємо покажчик 'arr' на новий масив
    arr = tempPtr;
}

// Функція для виведення елементів масиву
// Приймає покажчик на масив та його розмір (за константним посиланням, щоб уникнути випадкових змін)
void printArr(int* arr, const int& size) {
    for (int i = 0; i < size; i++) {
        cout << arr[i] << "  ";
    }
    cout << endl;
}

// Функція, яка повертає посилання на максимальний елемент масиву
// Це дозволяє змінювати сам елемент масиву через повернене посилання.
int& rmax(int arr[], int size) {
    int im = 0; // Індекс максимального елемента
    for (int i = 1; i < size; i++) {
        // Якщо поточний елемент arr[i] більший за елемент за індексом im,
        // то im стає i, інакше im залишається тим самим.
        im = arr[im] > arr[i] ? im : i; // Тернарний оператор
    }
    return arr[im]; // Повертаємо посилання на знайдений максимальний елемент
}

// Шаблонна функція для обміну значень
// Працює з будь-якими типами даних завдяки шаблонам.
// Приймає параметри за посиланням, щоб змінити оригінальні змінні.
template <typename T> void SwapValues(T& left, T& right) {
    T temp = left; // Зберігаємо значення лівого елемента у тимчасову змінну
    left = right;  // Присвоюємо значення правого елемента лівому
    right = temp;  // Присвоюємо збережене тимчасове значення правому елементу
}
